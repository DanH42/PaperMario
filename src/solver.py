from .board import paperMarioBoard, move
from copy import deepcopy
from collections import deque	


class paperMarioSolver:
	def __init__(self, startingBoard, moves, boss=False):
		self.board = paperMarioBoard(startingBoard)
		self.initialMoves = moves
		self.moves = moves


	def resetState(self):
		self.board.resetState()
		self.moves = self.initialMoves


	def findSolution(self,strategy="BFS",printSolution=True):
		# Doesn't return anything, but instead processes the move array generated by solution
		# strategies and outputs a human-readable set of instructions
		if strategy == "DFS":
			solution = self.findSolutionDFS()
		elif strategy == "BFS":
			solution = self.findSolutionBFS()
		elif strategy == "OLD":
			return False # do nothing because this legacy solver prints solutions in-method
		if not solution:
			return False
		else:
			if (printSolution):
				print("A solution was found in", len(solution), "move(s)")
				for solutionMove in solution:
					print(solutionMove)
			return True


	def findSolutionBFS(self):
		self.resetState()
		# solutions are stored as tuple ([moves made], nextMove) in a queue
		frontier = deque()
		for testMove in move.getAllMoves():
			frontier.append(([], testMove))
		while self.moves > 0:
			queue = deepcopy(frontier)
			frontier = deque()
			while queue:
				path, testMove = queue.popleft()
				for lastMove in path:
					self.board.makeMove(lastMove)
				self.board.makeMove(testMove)
				path.append(testMove)
				if self.board.isSolution():
					return path
				else:
					self.board.resetState()
					for nextMove in move.getAllMoves():
						if not (nextMove.type == testMove.type and nextMove.index == testMove.index):
							frontier.append((path.copy(), nextMove))
			self.moves -= 1
		return []


	def findSolutionDFS(self):
		self.resetState()
		solution = []
		for testMove in move.getAllMoves():
			self.board.makeMove(testMove)
			self.moves -= 1
			if self.board.isSolution():
				solution.append(testMove)
				return solution
			elif self.moves > 0:
				nextMoveSolver = paperMarioSolver(self.board, self.moves)
				nextMove = nextMoveSolver.findSolutionDFS()
				if nextMove:
					solution.append(testMove)
					solution += nextMove
					return solution
			else:
				self.resetState()
		return solution


	def findSolutionOld(self):
	# ring move -> index 0-3, amount 1-11
	# column move -> index 0-5, amount 1-7
		for moveIndex in range(86):
			if moveIndex < 4*11:
				index = moveIndex//11
				amount = moveIndex%11+1
				self.ringMove(index, amount)
				if self.isSolution():
					print("isSolution evaluated to true for")
					print("ring",index,amount)
					print()
					self.showState()
					return True
				elif self.moves > 0:
					nextMoveSolver = paperMarioSolver(self.board, self.moves)
					if nextMoveSolver.findSolutionOld():
						print("isSolution evaluated to true for")
						print("ring", index, amount)
						print("with a subsequent move\n")
						self.showState()
						return True
					else:
						self.resetState()
				else:
					self.resetState()
			else:
				index = (moveIndex-4*11)//7
				amount = (moveIndex-4*11)%7+1
				self.lineMove(index, amount)
				if self.isSolution():
					print("isSolution evaluated to true for")
					print("line",index,amount)
					print()
					self.showState()
					return True
				elif self.moves > 0:
					nextMoveSolver = paperMarioSolver(self.board, self.moves)
					if nextMoveSolver.findSolutionOld():
						print("isSolution evaluated to true for")
						print("line", index, amount)
						print("with a subsequent move\n")
						self.showState()
						return True
					else:
						self.resetState()
				else:
					self.resetState()
		return False