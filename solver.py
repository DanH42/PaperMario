from board import paperMarioBoard, move
from copy import deepcopy

class paperMarioSolver:
	def __init__(self, startingBoard, moves, boss=False):
		self.board = paperMarioBoard(startingBoard)
		self.initialMoves = moves
		self.moves = moves

	def resetState(self):
		self.board.resetState()
		self.moves = self.initialMoves

	def findSolution(self,strategy="DFS",printSolution=True):
		# Doesn't return anything, but instead processes the move array generated by solution
		# strategies and outputs a human-readable set of instructions
		if strategy == "DFS":
			solution = self.findSolutionDFS()
			if not solution:
				return False
			else:
				if (printSolution):
					print("A solution was found in", len(solution), "moves")
					for solutionMove in solution:
						print(solutionMove)
				return True
		elif strategy == "OLD":
			return False
			# do nothing because this legacy solver prints solutions in-method

	def findSolutionDFS(self):
		solution = []
		for testMove in move.getAllMoves():
			self.board.makeMove(testMove)
			self.moves -= 1
			if self.board.isSolution():
				solution.append(testMove)
				return solution
			elif self.moves > 0:
				nextMoveSolver = paperMarioSolver(self.board, self.moves)
				nextMove = nextMoveSolver.findSolutionDFS()
				if nextMove:
					solution.append(testMove)
					solution += nextMove
					return solution
			else:
				self.resetState()
		return solution

	def findSolutionOld(self):
	# ring move -> index 0-3, amount 1-11
	# column move -> index 0-5, amount 1-7
		for moveIndex in range(86):
			if moveIndex < 4*11:
				index = moveIndex//11
				amount = moveIndex%11+1
				self.ringMove(index, amount)
				if self.isSolution():
					print("isSolution evaluated to true for")
					print("ring",index,amount)
					print()
					self.showState()
					return True
				elif self.moves > 0:
					nextMoveSolver = paperMarioSolver(self.board, self.moves)
					if nextMoveSolver.findSolutionOld():
						print("isSolution evaluated to true for")
						print("ring", index, amount)
						print("with a subsequent move\n")
						self.showState()
						return True
					else:
						self.resetState()
				else:
					self.resetState()
			else:
				index = (moveIndex-4*11)//7
				amount = (moveIndex-4*11)%7+1
				self.lineMove(index, amount)
				if self.isSolution():
					print("isSolution evaluated to true for")
					print("line",index,amount)
					print()
					self.showState()
					return True
				elif self.moves > 0:
					nextMoveSolver = paperMarioSolver(self.board, self.moves)
					if nextMoveSolver.findSolutionOld():
						print("isSolution evaluated to true for")
						print("line", index, amount)
						print("with a subsequent move\n")
						self.showState()
						return True
					else:
						self.resetState()
				else:
					self.resetState()
		return False